<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>软件构造 5.15 | Gridea</title>
<link rel="shortcut icon" href="https://daydream-noquitter.github.io/coding.github.io//favicon.ico?v=1654172278695">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://daydream-noquitter.github.io/coding.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="软件构造 5.15 | Gridea - Atom Feed" href="https://daydream-noquitter.github.io/coding.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="上周因为复习形式语言自动机鸽掉了，这周不能鸽了
其实软件构造的思想非常自然
承认：
1.人都是会犯错的 ，再聪明的程序员，业务经理也是会犯错的，那么我们应该设计的不是一个依赖于不发生错误的系统，而是一个允许错误发生过并且修改的一个系统或者机..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://daydream-noquitter.github.io/coding.github.io/">
  <img class="avatar" src="https://daydream-noquitter.github.io/coding.github.io//images/avatar.png?v=1654172278695" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              软件构造 5.15
            </h2>
            <div class="post-info">
              <span>
                2022-05-15
              </span>
              <span>
                6 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>上周因为复习形式语言自动机鸽掉了，这周不能鸽了<br>
其实软件构造的思想非常自然<br>
承认：<br>
1.人都是会犯错的 ，再聪明的程序员，业务经理也是会犯错的，那么我们应该设计的不是一个依赖于不发生错误的系统，而是一个允许错误发生过并且修改的一个系统或者机制 ，这就是规约最重要的作用<br>
2.在人实现思维的过程中，程序员更像是进入其中一样，就像我们需要一个地图或者一个无人机 GPS之类的在上指引着我们一样，规约也一样，它像是我们在实现这件事情的时候，先提前约定好我们做什么事情，而不是我们在做事情的时候，一脸发懵的想我们该干什么，不该干什么。这有助于我们更优雅的完成任务<br>
3.人总会犯错的，犯错了就要找背锅的，那么互相扯皮肯定没啥意思，一纸规约正好解决了这个问题<br>
4.人在实现完一个程序的时候，一定是非常开心的，TA并不愿意去想我费了这么大劲写好的代码有什么问题，那么提前写测试或者规约就有这个好处，因为它有助于你在程序开发完之后重新客观审视自己的代码有没有问题。<br>
5.规约与提前测试，实际上非常符合人的心理波动与行为规律。我们思考全局最合适的时候，其一是在任务开始前，其二在任务结束后，其三在任务卡住的时候。我们并不是平白无故的增加工作量或者思考量，我们只是将工作量或者思考量迁移到之前，并且节约了更大的力气和避免了更多的麻烦。</p>
<p>希望CSAPP rp ++</p>
<p>等价类测试的思想太绝妙了，它正好解决了我思维的不足<br>
其实对于一个发散性思维或者活跃思维的人来说，最大的麻烦就是想的不全或者草率，而等价类测试正好解决了这个问题，因为它正好覆盖了问题可能出现的全部情况。<br>
讲一个王子探宝盒的故事（自己瞎编的），从前有一个王子，他去某一个神秘领域里面探险，他的面前有九个坑，分别对应九个洞穴，每个洞穴都有n层，n未知，某个洞穴的最低层有着他所需要的一切最宝贵的东西，王子可以做的事情，有往下一层，在某一层的部分区域探索，做出一个决定，在这一层继续探索，下一层去探索（当然，前提是发现了到下一层的路），回到上一层（当然前提是他想到了回到上一层），他所具有的属性，Hp，血量，VP，体力，RP，人品（幸运程度），SAN（清醒程度） ，TP（思考能力），AP（执行程度），LST（所必须的最晚离开宝地的时间），LPT（自己规定的离开某处的时间），TTT（想要拿到宝贵的东西的欲望程度），DVP（对于宝贵的东西的认识程度）。目前想到的属性就这些。<br>
有很多种任务类型 ，可以想到的，有<br>
1.到每一个地方，都会摸索到宝贵的东西相关的线索<br>
2.到每一个地方，都会逐渐认识到宝贵的东西是什么，但是得不到它在哪里的线索，而且认识对于最后获得没有影响。<br>
3.到每一个地方，都会逐渐认识到宝贵的东西是什么，但是得不到它在哪里的线索，而且认识对于最后获得有影响，比如必须要探索到足够的认识，才能最终获得<br>
4.到每一个地方，只有消耗，并无补充，最后在一定时间之后如果不返回到某个出口的话，就离不开了<br>
5.到每一个地方，只有消耗，并无补充，最后在一定时间之后如果不得到宝贵的东西的话，就离不开了<br>
6.到每一个地方，只有消耗，又有补充，最后在一定时间之后如果不得到宝贵的东西的话，就离不开了<br>
那么其实上述可以很清晰的看到并没有遍历全这个故事的所有模型对吧，那么这个故事未完待续，如果有人在提前看到的话，那就自行脑补体会吧（嘿嘿）。<br>
古希腊的浪漫，东方古典哲学的辨思，还是很有意思的。<br>
—————— 与技术无关，纯个人瞎说点什么，怕自己以后忘了。<br>
可以想到的，人不会总在一个评价体系里呆着，一个人的人生可以看作是从一个评价体系到另外一个评价体系，那么我们把所有的精力都用来在这个评价体系里达到最高点，显然并不是最优解，那么比较合理的是事实上我们既为目前的体系做出足够的努力，又为将来的评价体系做出一定的努力。那么有意思的事情就来了，我们可能会做出我们意识不到对自己将来有用的事情，这也是可以想到的，那么我们往往的自我评估都是从自己出发的，也就是并不一定非常科学，很有可能我们现在做了对以后有用的事情，但是我们现在意识不到，hhh，这很正常了。那么我们只能尽量做出科学的评价，并且尽量做出科学的安排与规划。<br>
活到下一集很重要，但它不是人生的全部，对吧。</p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://daydream-noquitter.github.io/coding.github.io/post/ruan-jian-gou-zao-51-java-yu-fa/">
              <h3 class="post-title">
                软件构造 5.1 （java语法）
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://daydream-noquitter.github.io/coding.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
